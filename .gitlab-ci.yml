# .gitlab-ci.yml
# GitLab CI/CD pipeline for the Nx Monorepo

# Define the stages of the pipeline
stages:
  - install
  - affected
  - deploy

# Define variables for the base/head comparison
variables:
  # Base is the main branch (last successful commit on main)
  # Head is the current commit (HEAD)
  NX_BASE: $CI_DEFAULT_BRANCH
  NX_HEAD: $CI_COMMIT_SHA

# --- 1. Install Dependencies Stage ---
install_deps:
  stage: install
  image: node:lts-alpine
  script:
    - npm ci # Clean install
    - npx nx affected:graph --base=$NX_BASE --head=$NX_HEAD # Run once to cache the graph
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules
      - .nx/cache
  artifacts:
    expire_in: 1 week
    when: always
    paths:
      - .nx/cache
  # Caching is crucial for performance

# --- 2. Affected Tasks Stage (Build & Test) ---
affected_tasks:
  stage: affected
  image: node:lts-alpine
  needs: [install_deps]
  script:
    - npm install -g @nrwl/cli # Install Nx CLI globally for affected commands
    # Lint only the affected projects
    - echo "Running lint for affected projects..."
    - npx nx affected --target=lint --base=$NX_BASE --head=$NX_HEAD --parallel=3

    # Test only the affected projects
    - echo "Running tests for affected projects..."
    - npx nx affected --target=test --base=$NX_BASE --head=$NX_HEAD --parallel=3

    # Build only the affected projects and save the result (e.g., Docker image)
    - echo "Building affected projects..."
    - npx nx affected --target=build --base=$NX_BASE --head=$NX_HEAD --parallel=3
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules
      - .nx/cache
    policy: pull-push # Reuse cache from install stage

# --- 3. Deploy Stage (Only run if a project was affected and needs deployment) ---

# API Gateway Deployment Job (Web Service)
deploy_api_gateway:
  stage: deploy
  image: alpine/curl:latest # A minimal image with curl to trigger the deploy hook
  needs: [affected_tasks]
  script: |
    echo "Checking if API Gateway was affected..."
    # The 'print-affected' command checks if the project was touched
    AFFECTED_PROJECTS=$(npx nx print-affected --type=apps --base=$NX_BASE --head=$NX_HEAD --plain | tr -d '\n' | grep 'api-gateway' || true)

    # Check if the project name is in the affected list
    if [ -n "$AFFECTED_PROJECTS" ]; then
      echo "✅ API Gateway was affected. Triggering Render deploy hook..."
      # Use the secret environment variable to call the Render Web Service Deploy Hook
      curl -X POST "$RENDER_API_DEPLOY_HOOK"
    else
      echo "❌ API Gateway was NOT affected. Skipping deployment."
    fi
  # This rule ensures the job ONLY runs if any file changes
  # (though the script handles which hook to call based on the specific change)
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: always

# Angular Shell Deployment Job (Static Site)
deploy_angular_shell:
  stage: deploy
  image: alpine/curl:latest
  needs: [affected_tasks]
  script: |
    echo "Checking if Angular Shell was affected..."
    # Note: the app in this repo is named 'nav-shell' (apps/nav-shell)
    AFFECTED_PROJECTS=$(npx nx print-affected --type=apps --base=$NX_BASE --head=$NX_HEAD --plain | tr -d '\n' | grep 'nav-shell' || true)

    if [ -n "$AFFECTED_PROJECTS" ]; then
      echo "✅ Angular Shell (nav-shell) was affected. Triggering Render deploy hook..."
      # Use the secret environment variable to call the Render Static Site Deploy Hook
      curl -X POST "$RENDER_SHELL_DEPLOY_HOOK"
    else
      echo "❌ Angular Shell (nav-shell) was NOT affected. Skipping deployment."
    fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: always
